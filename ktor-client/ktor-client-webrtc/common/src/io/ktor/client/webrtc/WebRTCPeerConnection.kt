/*
 * Copyright 2014-2025 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.
 */

package io.ktor.client.webrtc

import io.ktor.utils.io.core.Closeable
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharedFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asSharedFlow
import kotlinx.coroutines.flow.asStateFlow

/**
 * Base class for operations performed on media tracks.
 */
public sealed class Operation<T>(public val item: T)

/**
 * Represents an add operation for a media track.
 */
public class Add<T>(item: T) : Operation<T>(item)

/**
 * Represents a remove operation for a media track.
 */
public class Remove<T>(item: T) : Operation<T>(item)

/**
 * Abstract class representing a peer-to-peer connection.
 *
 * @param iceCandidatesReplay The number of ICE candidates to replay when a new collector is added.
 * @param remoteTracksReplay The number of remote track operations to replay when a new collector is added.
 *
 * @see <a href="https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection">MDN RTCPeerConnection</a>
 */
public abstract class WebRtcPeerConnection(iceCandidatesReplay: Int, remoteTracksReplay: Int) : Closeable {
    protected val currentStats: MutableStateFlow<List<WebRTC.Stats>> = MutableStateFlow(listOf())

    /**
     * Flow of connection statistics.
     */
    public val statsFlow: StateFlow<List<WebRTC.Stats>> = currentStats.asStateFlow()

    protected val iceCandidates: MutableSharedFlow<WebRTC.IceCandidate> = MutableSharedFlow(iceCandidatesReplay)

    /**
     * Flow of ICE candidates generated by this peer connection.
     */
    public val iceCandidateFlow: SharedFlow<WebRTC.IceCandidate> = iceCandidates.asSharedFlow()

    protected val currentIceConnectionState: MutableStateFlow<WebRTC.IceConnectionState> =
        MutableStateFlow(WebRTC.IceConnectionState.NEW)

    /**
     * Flow of ICE connection state changes.
     */
    public val iceConnectionStateFlow: StateFlow<WebRTC.IceConnectionState> = currentIceConnectionState.asStateFlow()

    protected val currentConnectionState: MutableStateFlow<WebRTC.ConnectionState> =
        MutableStateFlow(WebRTC.ConnectionState.NEW)

    /**
     * Flow of connection state changes.
     */
    public val connectionStateFlow: StateFlow<WebRTC.ConnectionState> = currentConnectionState.asStateFlow()

    protected val currentIceGatheringState: MutableStateFlow<WebRTC.IceGatheringState> =
        MutableStateFlow(WebRTC.IceGatheringState.NEW)

    /**
     * Flow of ICE gathering state changes.
     */
    public val iceGatheringStateFlow: StateFlow<WebRTC.IceGatheringState> = currentIceGatheringState.asStateFlow()

    protected val currentSignalingState: MutableStateFlow<WebRTC.SignalingState> =
        MutableStateFlow(WebRTC.SignalingState.CLOSED)

    /**
     * Flow of signaling state changes.
     */
    public val signalingStateFlow: StateFlow<WebRTC.SignalingState> = currentSignalingState.asStateFlow()

    protected val remoteTracks: MutableSharedFlow<Operation<WebRTCMedia.Track>> = MutableSharedFlow(remoteTracksReplay)

    /**
     * Flow of remote track operations (add/remove).
     */
    public val remoteTracksFlow: SharedFlow<Operation<WebRTCMedia.Track>> = remoteTracks.asSharedFlow()

    /**
     * The local session description for this connection.
     */
    public abstract val localDescription: WebRTC.SessionDescription?

    /**
     * The remote session description for this connection.
     */
    public abstract val remoteDescription: WebRTC.SessionDescription?

    protected var negotiationNeededCallback: () -> Unit = {}

    /**
     * Returns platform-specific peer connection used under the hood. Use with caution.
     */
    public abstract fun getNativeConnection(): Any

    /**
     * Creates an SDP offer for establishing a connection.
     *
     * @return The session description representing the offer.
     */
    public abstract suspend fun createOffer(): WebRTC.SessionDescription

    /**
     * Creates an SDP answer in response to a received offer.
     *
     * @return The session description representing the answer.
     */
    public abstract suspend fun createAnswer(): WebRTC.SessionDescription

    /**
     * Sets the local session description.
     */
    public abstract suspend fun setLocalDescription(description: WebRTC.SessionDescription)

    /**
     * Sets the remote session description.
     */
    public abstract suspend fun setRemoteDescription(description: WebRTC.SessionDescription)

    /**
     * Adds a remote ICE candidate to this connection.
     */
    public abstract suspend fun addIceCandidate(candidate: WebRTC.IceCandidate)

    /**
     * Adds a media track to this connection.
     *
     * @param track The media track to add.
     * @return An RTP sender for the added track.
     */
    public abstract suspend fun addTrack(track: WebRTCMedia.Track): WebRTC.RtpSender

    /**
     * Removes a track from this connection using its RTP sender.
     *
     * @param sender The RTP sender for the track to remove.
     */
    public abstract suspend fun removeTrack(sender: WebRTC.RtpSender)

    /**
     * Removes a track from this connection.
     *
     * @param track The media track to remove.
     */
    public abstract suspend fun removeTrack(track: WebRTCMedia.Track)

    /**
     * Restarts ICE negotiation for this connection.
     * Should trigger `onNegotiationNeeded` callback.
     * The next offer will be created with `iceRestart` option.
     */
    public abstract fun restartIce()

    /**
     * Sets a callback to be invoked when negotiation (offer-answer exchange, etc.) is needed for this connection.
     */
    public fun onNegotiationNeeded(callback: () -> Unit) {
        negotiationNeededCallback = callback
    }
}
